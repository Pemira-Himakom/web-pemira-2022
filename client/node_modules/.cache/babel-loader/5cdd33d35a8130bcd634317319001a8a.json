{"ast":null,"code":"import { __rest } from 'tslib';\nimport { findSpring, calcAngularFreq } from '../utils/find-spring.mjs';\nconst durationKeys = [\"duration\", \"bounce\"];\nconst physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\nfunction isSpringType(options, keys) {\n  return keys.some(key => options[key] !== undefined);\n}\nfunction getSpringOptions(options) {\n  let springOptions = Object.assign({\n    velocity: 0.0,\n    stiffness: 100,\n    damping: 10,\n    mass: 1.0,\n    isResolvedFromDuration: false\n  }, options);\n  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {\n    const derived = findSpring(options);\n    springOptions = Object.assign(Object.assign(Object.assign({}, springOptions), derived), {\n      velocity: 0.0,\n      mass: 1.0\n    });\n    springOptions.isResolvedFromDuration = true;\n  }\n  return springOptions;\n}\nfunction spring(_a) {\n  var {\n      from = 0.0,\n      to = 1.0,\n      restSpeed = 2,\n      restDelta\n    } = _a,\n    options = __rest(_a, [\"from\", \"to\", \"restSpeed\", \"restDelta\"]);\n  const state = {\n    done: false,\n    value: from\n  };\n  let {\n    stiffness,\n    damping,\n    mass,\n    velocity,\n    duration,\n    isResolvedFromDuration\n  } = getSpringOptions(options);\n  let resolveSpring = zero;\n  let resolveVelocity = zero;\n  function createSpring() {\n    const initialVelocity = velocity ? -(velocity / 1000) : 0.0;\n    const initialDelta = to - from;\n    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n    const undampedAngularFreq = Math.sqrt(stiffness / mass) / 1000;\n    if (restDelta === undefined) {\n      restDelta = Math.min(Math.abs(to - from) / 100, 0.4);\n    }\n    if (dampingRatio < 1) {\n      const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\n      resolveSpring = t => {\n        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n        return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));\n      };\n      resolveVelocity = t => {\n        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n        return dampingRatio * undampedAngularFreq * envelope * (Math.sin(angularFreq * t) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq + initialDelta * Math.cos(angularFreq * t)) - envelope * (Math.cos(angularFreq * t) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) - angularFreq * initialDelta * Math.sin(angularFreq * t));\n      };\n    } else if (dampingRatio === 1) {\n      resolveSpring = t => to - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);\n    } else {\n      const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n      resolveSpring = t => {\n        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n        const freqForT = Math.min(dampedAngularFreq * t, 300);\n        return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;\n      };\n    }\n  }\n  createSpring();\n  return {\n    next: t => {\n      const current = resolveSpring(t);\n      if (!isResolvedFromDuration) {\n        const currentVelocity = resolveVelocity(t) * 1000;\n        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n        const isBelowDisplacementThreshold = Math.abs(to - current) <= restDelta;\n        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;\n      } else {\n        state.done = t >= duration;\n      }\n      state.value = state.done ? to : current;\n      return state;\n    },\n    flipTarget: () => {\n      velocity = -velocity;\n      [from, to] = [to, from];\n      createSpring();\n    }\n  };\n}\nspring.needsInterpolation = (a, b) => typeof a === \"string\" || typeof b === \"string\";\nconst zero = _t => 0;\nexport { spring };","map":{"version":3,"names":["__rest","findSpring","calcAngularFreq","durationKeys","physicsKeys","isSpringType","options","keys","some","key","undefined","getSpringOptions","springOptions","Object","assign","velocity","stiffness","damping","mass","isResolvedFromDuration","derived","spring","_a","from","to","restSpeed","restDelta","state","done","value","duration","resolveSpring","zero","resolveVelocity","createSpring","initialVelocity","initialDelta","dampingRatio","Math","sqrt","undampedAngularFreq","min","abs","angularFreq","t","envelope","exp","sin","cos","dampedAngularFreq","freqForT","sinh","cosh","next","current","currentVelocity","isBelowVelocityThreshold","isBelowDisplacementThreshold","flipTarget","needsInterpolation","a","b","_t"],"sources":["/Users/josiahfarrelsuwito/pemira/web-pemira-2022/client/node_modules/popmotion/dist/es/animations/generators/spring.mjs"],"sourcesContent":["import { __rest } from 'tslib';\nimport { findSpring, calcAngularFreq } from '../utils/find-spring.mjs';\n\nconst durationKeys = [\"duration\", \"bounce\"];\nconst physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\nfunction isSpringType(options, keys) {\n    return keys.some((key) => options[key] !== undefined);\n}\nfunction getSpringOptions(options) {\n    let springOptions = Object.assign({ velocity: 0.0, stiffness: 100, damping: 10, mass: 1.0, isResolvedFromDuration: false }, options);\n    if (!isSpringType(options, physicsKeys) &&\n        isSpringType(options, durationKeys)) {\n        const derived = findSpring(options);\n        springOptions = Object.assign(Object.assign(Object.assign({}, springOptions), derived), { velocity: 0.0, mass: 1.0 });\n        springOptions.isResolvedFromDuration = true;\n    }\n    return springOptions;\n}\nfunction spring(_a) {\n    var { from = 0.0, to = 1.0, restSpeed = 2, restDelta } = _a, options = __rest(_a, [\"from\", \"to\", \"restSpeed\", \"restDelta\"]);\n    const state = { done: false, value: from };\n    let { stiffness, damping, mass, velocity, duration, isResolvedFromDuration, } = getSpringOptions(options);\n    let resolveSpring = zero;\n    let resolveVelocity = zero;\n    function createSpring() {\n        const initialVelocity = velocity ? -(velocity / 1000) : 0.0;\n        const initialDelta = to - from;\n        const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n        const undampedAngularFreq = Math.sqrt(stiffness / mass) / 1000;\n        if (restDelta === undefined) {\n            restDelta = Math.min(Math.abs(to - from) / 100, 0.4);\n        }\n        if (dampingRatio < 1) {\n            const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\n            resolveSpring = (t) => {\n                const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n                return (to -\n                    envelope *\n                        (((initialVelocity +\n                            dampingRatio * undampedAngularFreq * initialDelta) /\n                            angularFreq) *\n                            Math.sin(angularFreq * t) +\n                            initialDelta * Math.cos(angularFreq * t)));\n            };\n            resolveVelocity = (t) => {\n                const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n                return (dampingRatio *\n                    undampedAngularFreq *\n                    envelope *\n                    ((Math.sin(angularFreq * t) *\n                        (initialVelocity +\n                            dampingRatio *\n                                undampedAngularFreq *\n                                initialDelta)) /\n                        angularFreq +\n                        initialDelta * Math.cos(angularFreq * t)) -\n                    envelope *\n                        (Math.cos(angularFreq * t) *\n                            (initialVelocity +\n                                dampingRatio *\n                                    undampedAngularFreq *\n                                    initialDelta) -\n                            angularFreq *\n                                initialDelta *\n                                Math.sin(angularFreq * t)));\n            };\n        }\n        else if (dampingRatio === 1) {\n            resolveSpring = (t) => to -\n                Math.exp(-undampedAngularFreq * t) *\n                    (initialDelta +\n                        (initialVelocity + undampedAngularFreq * initialDelta) *\n                            t);\n        }\n        else {\n            const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n            resolveSpring = (t) => {\n                const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n                const freqForT = Math.min(dampedAngularFreq * t, 300);\n                return (to -\n                    (envelope *\n                        ((initialVelocity +\n                            dampingRatio * undampedAngularFreq * initialDelta) *\n                            Math.sinh(freqForT) +\n                            dampedAngularFreq *\n                                initialDelta *\n                                Math.cosh(freqForT))) /\n                        dampedAngularFreq);\n            };\n        }\n    }\n    createSpring();\n    return {\n        next: (t) => {\n            const current = resolveSpring(t);\n            if (!isResolvedFromDuration) {\n                const currentVelocity = resolveVelocity(t) * 1000;\n                const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n                const isBelowDisplacementThreshold = Math.abs(to - current) <= restDelta;\n                state.done =\n                    isBelowVelocityThreshold && isBelowDisplacementThreshold;\n            }\n            else {\n                state.done = t >= duration;\n            }\n            state.value = state.done ? to : current;\n            return state;\n        },\n        flipTarget: () => {\n            velocity = -velocity;\n            [from, to] = [to, from];\n            createSpring();\n        },\n    };\n}\nspring.needsInterpolation = (a, b) => typeof a === \"string\" || typeof b === \"string\";\nconst zero = (_t) => 0;\n\nexport { spring };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}